<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Color Palette & Pattern Generator</title>
    <style>
        :root {
            --primary-color: #27ae60;
            --primary-hover: #2ecc71;
            --background-dark: #1a1a1a;
            --background-medium: #2d2d2d;
            --background-light: #3a3a3a;
            --background-lighter: #444444;
            --text-light: #ffffff;
            --text-dim: #aaaaaa;
            --accent-color: #f1c40f;
            --border-radius: 8px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--background-dark);
            color: var(--text-light);
            line-height: 1.5;
            overflow-x: hidden;
        }
        
        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .app-title {
            color: var(--accent-color);
            font-size: 2rem;
            margin-bottom: 20px;
            text-align: center;
        }
        
        /* Color picker styles */
        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            background-color: var(--background-medium);
            padding: 20px;
            border-radius: var(--border-radius);
        }
        
        .color-input-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }
        
        input[type="color"] {
            width: 60px;
            height: 60px;
            border: 2px solid white;
            border-radius: var(--border-radius);
            cursor: pointer;
            background: none;
            padding: 0;
        }
        
        input[type="text"] {
            padding: 12px 15px;
            border-radius: var(--border-radius);
            border: none;
            background-color: var(--background-light);
            color: var(--text-light);
            font-family: monospace;
            width: 120px;
            font-size: 1rem;
        }
        
        input[type="number"] {
            padding: 12px 15px;
            border-radius: var(--border-radius);
            border: none;
            background-color: var(--background-light);
            color: var(--text-light);
            width: 80px;
            font-size: 1rem;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            color: var(--text-dim);
            margin-right: 5px;
        }
        
        select {
            padding: 12px;
            border-radius: var(--border-radius);
            border: none;
            background-color: var(--background-light);
            color: var(--text-light);
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
            padding-right: 35px;
        }
        
        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 25px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            min-width: 150px;
        }
        
        .btn:hover {
            background-color: var(--primary-hover);
        }
        
        .btn:disabled {
            background-color: var(--background-light);
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background-color: var(--background-light);
            color: var(--text-light);
        }
        
        .btn-secondary:hover {
            background-color: var(--background-lighter);
        }
        
        .btn-accent {
            background-color: var(--accent-color);
            color: var(--background-dark);
        }
        
        .btn-accent:hover {
            background-color: #f4d03f;
        }
        
        .section-title {
            color: var(--accent-color);
            font-size: 1.8rem;
            margin-bottom: 20px;
        }
        
        .section {
            margin-bottom: 30px;
        }
        
        .palette-display {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .color-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .color-box {
            width: 70px;
            height: 70px;
            border-radius: var(--border-radius);
            cursor: pointer;
            margin-bottom: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
            border: 2px solid var(--background-lighter);
        }
        
        .color-box:hover {
            transform: scale(1.05);
        }
        
        .color-hex {
            font-family: monospace;
            font-size: 0.9rem;
            background-color: var(--background-light);
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .blocks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 15px;
        }
        
        .block-item {
            background-color: var(--background-light);
            border-radius: var(--border-radius);
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            position: relative;
        }
        
        .block-item:hover {
            transform: translateY(-3px);
        }
        
        .block-item.selected {
            border: 2px solid var(--accent-color);
        }
        
        .block-image {
            width: 64px;
            height: 64px;
            image-rendering: pixelated;
            margin-bottom: 12px;
        }
        
        .block-name {
            font-size: 0.9rem;
            text-align: center;
            word-wrap: break-word;
            line-height: 1.3;
        }
        
        .block-select-checkbox {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        /* Pattern generator styles */
        .pattern-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            background-color: var(--background-medium);
            padding: 20px;
            border-radius: var(--border-radius);
        }
        
        .selected-blocks-container {
            background-color: var(--background-medium);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
        }
        
        .selected-blocks {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .selected-block {
            background-color: var(--background-light);
            border-radius: var(--border-radius);
            padding: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .selected-block img {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
        }
        
        .pattern-preview-wrapper {
            background-color: var(--background-lighter);
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 30px;
        }
        
        .pattern-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .pattern-preview-header h3 {
            margin: 0;
        }
        
        .zoom-buttons {
            display: flex;
            gap: 5px;
        }
        
        .zoom-btn {
            background-color: var(--background-light);
            color: white;
            border: none;
            border-radius: 4px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
        }
        
        .pattern-grid-container {
            display: flex;
            justify-content: center;
            overflow: auto;
            max-width: 100%;
        }
        
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-size, 8), minmax(40px, 50px));
            gap: 2px;
        }
        
        .pattern-cell {
            aspect-ratio: 1/1;
            background-color: var(--background-light);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .pattern-cell img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            image-rendering: pixelated;
        }
        
        .pattern-generator {
            display: none;
            margin-top: 40px;
            border-top: 1px solid var(--background-light);
            padding-top: 40px;
        }
        
        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
        }
        
        .help-text {
            background-color: var(--background-light);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            border-left: 4px solid var(--accent-color);
        }
        
        .footer {
            font-size: 0.9rem;
            color: var(--text-dim);
            text-align: center;
            margin-top: 40px;
            padding-top: 15px;
            border-top: 1px solid var(--background-medium);
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--background-light);
            border-top: 5px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .results-container {
            display: none;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .app-title {
                font-size: 1.6rem;
            }
            
            .color-picker-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .color-input-group {
                width: 100%;
                margin-bottom: 15px;
                flex-wrap: wrap;
            }
            
            .control-group {
                width: 100%;
                justify-content: space-between;
            }
            
            .btn {
                width: 100%;
            }
            
            .blocks-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
            }
            
            .block-item {
                padding: 10px;
            }
            
            .block-image {
                width: 40px;
                height: 40px;
            }
            
            .color-box {
                width: 60px;
                height: 60px;
            }
            
            .section-title {
                font-size: 1.5rem;
            }
            
            .pattern-grid {
                grid-template-columns: repeat(var(--grid-size, 8), minmax(30px, 40px));
            }
            
            .action-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <h1 class="app-title">Minecraft Color Palette & Pattern Generator</h1>
        
        <!-- Color Picker Section -->
        <div class="color-picker-container">
            <div class="color-input-group">
                <input type="color" id="color-picker" value="#ffffff">
                <input type="text" id="color-hex" value="#ffffff">
                <div class="control-group">
                    <label for="block-count">Blocks:</label>
                    <select id="block-count">
                        <option value="5" selected>5</option>
                        <option value="8">8</option>
                        <option value="10">10</option>
                    </select>
                </div>
            </div>
            <button id="find-btn" class="btn">Find Blocks</button>
        </div>
        
        <!-- Results Section -->
        <div id="results-container" class="results-container">
            <section class="section">
                <h2 class="section-title">Your Color Palette</h2>
                <div id="palette-display" class="palette-display">
                    <!-- Color palette items will be added here -->
                </div>
            </section>
            
            <section class="section">
                <h2 class="section-title">Matching Minecraft Blocks</h2>
                <div id="blocks-grid" class="blocks-grid">
                    <!-- Block items will be added here -->
                </div>
            </section>
            
            <div class="action-buttons">
                <button id="create-pattern-btn" class="btn btn-accent">Create Patterns With These Blocks</button>
            </div>
        </div>
        
        <!-- Pattern Generator Section (initially hidden) -->
        <div id="pattern-generator" class="pattern-generator">
            <h2 class="section-title">Create Patterns With Selected Blocks</h2>
            
            <div class="help-text">
                Select pattern type and size to create beautiful block patterns for your Minecraft builds!
            </div>
            
            <div class="pattern-controls">
                <div class="control-group">
                    <label for="pattern-type">Pattern Type:</label>
                    <select id="pattern-type">
                        <option value="checkerboard">Checkerboard</option>
                        <option value="stripes">Stripes</option>
                        <option value="random">Random</option>
                        <option value="border">Border</option>
                        <option value="diagonal">Diagonal</option>
                        <option value="circles">Circles</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="grid-size">Grid Size:</label>
                    <input type="number" id="grid-size" min="4" max="16" value="8">
                </div>
                
                <button id="generate-pattern-btn" class="btn">Generate Pattern</button>
            </div>
            
            <div class="selected-blocks-container">
                <h3>Selected Blocks for Pattern</h3>
                <div id="selected-blocks" class="selected-blocks">
                    <!-- Selected blocks will appear here -->
                </div>
            </div>
            
            <div class="pattern-preview-wrapper">
                <div class="pattern-preview-header">
                    <h3>Pattern Preview</h3>
                    <div class="zoom-buttons">
                        <button class="zoom-btn" id="zoom-out">-</button>
                        <button class="zoom-btn" id="zoom-in">+</button>
                    </div>
                </div>
                
                <div class="pattern-grid-container">
                    <div id="pattern-grid" class="pattern-grid">
                        <!-- Pattern cells will be generated here -->
                    </div>
                </div>
            </div>
        </div>
        
        <footer class="footer">
            <p>Created by Minecraft fans for Minecraft fans. Minecraft is owned by Mojang Studios.</p>
        </footer>
    </div>
    
    <div id="loading-overlay" class="loading-overlay">
        <div class="spinner"></div>
    </div>

    <script>
        // Global variables
        let allItems = [];
        let selectedItems = [];
        let palette = [];
        let selectedPatternBlocks = []; // Blocks selected for pattern generation
        let dominantColors = new Map(); // Cache for dominant colors in items
        let currentZoom = 1;
        const apiUrl = 'https://raw.githubusercontent.com/JHVIW/MineCatalog/main/minecraft-items.json';
        
        // Color catalog - organized by color groups for better matching
        const colorCatalog = {
            white: [
                "white_concrete", "white_wool", "white_terracotta", "white_stained_glass", 
                "bone_block", "diorite", "polished_diorite", "quartz_block", "snow_block", 
                "white_glazed_terracotta", "white_shulker_box", "white_concrete_powder",
                "calcite", "birch_planks", "birch_log", "birch_wood", "mushroom_stem"
            ],
            lightGray: [
                "light_gray_concrete", "light_gray_wool", "light_gray_terracotta", 
                "light_gray_stained_glass", "clay", "cobblestone", "stone", "andesite", 
                "polished_andesite", "light_gray_glazed_terracotta", "light_gray_concrete_powder"
            ],
            gray: [
                "gray_concrete", "gray_wool", "gray_terracotta", "gray_stained_glass",
                "gray_glazed_terracotta", "gray_concrete_powder", "polished_basalt", "basalt",
                "stone_bricks", "cracked_stone_bricks", "dead_brain_coral_block", "tuff"
            ],
            black: [
                "black_concrete", "black_wool", "black_terracotta", "black_stained_glass",
                "black_glazed_terracotta", "black_concrete_powder", "coal_block", 
                "obsidian", "blackstone", "polished_blackstone", "basalt", "deepslate",
                "polished_deepslate", "deepslate_tiles", "deepslate_bricks"
            ],
            red: [
                "red_concrete", "red_wool", "red_terracotta", "red_stained_glass",
                "red_glazed_terracotta", "red_concrete_powder", "red_mushroom_block",
                "nether_wart_block", "crimson_stem", "crimson_planks", "crimson_hyphae",
                "red_nether_bricks", "redstone_block", "redstone_ore", "nether_gold_ore"
            ],
            orange: [
                "orange_concrete", "orange_wool", "orange_terracotta", "orange_stained_glass",
                "orange_glazed_terracotta", "orange_concrete_powder", "copper_block",
                "cut_copper", "exposed_copper", "acacia_planks", "acacia_log", "acacia_wood",
                "pumpkin", "terracotta", "brown_mushroom_block"
            ],
            yellow: [
                "yellow_concrete", "yellow_wool", "yellow_terracotta", "yellow_stained_glass",
                "yellow_glazed_terracotta", "yellow_concrete_powder", "hay_block",
                "gold_block", "raw_gold_block", "bee_nest", "honeycomb_block",
                "honey_block", "sponge", "wet_sponge", "yellow_flower"
            ],
            lime: [
                "lime_concrete", "lime_wool", "lime_terracotta", "lime_stained_glass",
                "lime_glazed_terracotta", "lime_concrete_powder", "melon", "slime_block"
            ],
            green: [
                "green_concrete", "green_wool", "green_terracotta", "green_stained_glass",
                "green_glazed_terracotta", "green_concrete_powder", "moss_block",
                "emerald_block", "emerald_ore", "oak_leaves", "spruce_leaves", "jungle_leaves",
                "dark_oak_leaves", "dried_kelp_block", "seagrass", "cactus"
            ],
            cyan: [
                "cyan_concrete", "cyan_wool", "cyan_terracotta", "cyan_stained_glass",
                "cyan_glazed_terracotta", "cyan_concrete_powder", "prismarine",
                "prismarine_bricks", "dark_prismarine", "warped_stem", "warped_planks",
                "warped_hyphae", "oxidized_copper", "oxidized_cut_copper"
            ],
            lightBlue: [
                "light_blue_concrete", "light_blue_wool", "light_blue_terracotta", 
                "light_blue_stained_glass", "light_blue_glazed_terracotta", 
                "light_blue_concrete_powder", "ice", "packed_ice", "soul_soil"
            ],
            blue: [
                "blue_concrete", "blue_wool", "blue_terracotta", "blue_stained_glass",
                "blue_glazed_terracotta", "blue_concrete_powder", "blue_ice",
                "lapis_block", "lapis_ore", "diamond_block", "diamond_ore", "soul_soil"
            ],
            purple: [
                "purple_concrete", "purple_wool", "purple_terracotta", "purple_stained_glass",
                "purple_glazed_terracotta", "purple_concrete_powder", "purpur_block",
                "purpur_pillar", "amethyst_block", "budding_amethyst", "mycelium"
            ],
            magenta: [
                "magenta_concrete", "magenta_wool", "magenta_terracotta", "magenta_stained_glass",
                "magenta_glazed_terracotta", "magenta_concrete_powder", "purpur_block", 
                "chorus_flower", "chorus_plant", "amethyst_cluster"
            ],
            pink: [
                "pink_concrete", "pink_wool", "pink_terracotta", "pink_stained_glass",
                "pink_glazed_terracotta", "pink_concrete_powder", "brain_coral_block", 
                "bubble_coral_block", "cherry_planks", "cherry_log", "cherry_wood"
            ],
            brown: [
                "brown_concrete", "brown_wool", "brown_terracotta", "brown_stained_glass",
                "brown_glazed_terracotta", "brown_concrete_powder", "soul_sand",
                "oak_log", "oak_planks", "oak_wood", "jungle_log", "jungle_planks",
                "jungle_wood", "dark_oak_log", "dark_oak_planks", "dark_oak_wood",
                "spruce_log", "spruce_planks", "spruce_wood", "dirt", "coarse_dirt",
                "rooted_dirt", "mud", "mud_bricks", "packed_mud", "mangrove_log", 
                "mangrove_planks", "mangrove_wood", "mangrove_roots", "muddy_mangrove_roots"
            ]
        };
        
        // DOM elements
        const colorPicker = document.getElementById('color-picker');
        const colorHex = document.getElementById('color-hex');
        const blockCountSelect = document.getElementById('block-count');
        const findBtn = document.getElementById('find-btn');
        const resultsContainer = document.getElementById('results-container');
        const paletteDisplay = document.getElementById('palette-display');
        const blocksGrid = document.getElementById('blocks-grid');
        const createPatternBtn = document.getElementById('create-pattern-btn');
        const patternGenerator = document.getElementById('pattern-generator');
        const loadingOverlay = document.getElementById('loading-overlay');
        
        // Pattern generator elements
        const patternTypeSelect = document.getElementById('pattern-type');
        const gridSizeInput = document.getElementById('grid-size');
        const generatePatternBtn = document.getElementById('generate-pattern-btn');
        const selectedBlocksContainer = document.getElementById('selected-blocks');
        const patternGrid = document.getElementById('pattern-grid');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        
        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            loadData();
            
            // Event listeners for color palette
            colorPicker.addEventListener('input', updateColorHex);
            colorHex.addEventListener('input', updateColorPicker);
            findBtn.addEventListener('click', findMatchingBlocks);
            createPatternBtn.addEventListener('click', showPatternGenerator);
            
            // Event listeners for pattern generator
            generatePatternBtn.addEventListener('click', generatePattern);
            gridSizeInput.addEventListener('input', updateGridSize);
            zoomInBtn.addEventListener('click', zoomIn);
            zoomOutBtn.addEventListener('click', zoomOut);
            patternTypeSelect.addEventListener('change', generatePattern);
        });
        
        // Update grid size when input changes
        function updateGridSize() {
            const size = parseInt(gridSizeInput.value);
            
            if (size >= 4 && size <= 16) {
                patternGrid.style.setProperty('--grid-size', size);
                generatePattern();
            }
        }
        
        // Zoom in pattern preview
        function zoomIn() {
            if (currentZoom < 2) {
                currentZoom += 0.25;
                updateZoom();
            }
        }
        
        // Zoom out pattern preview
        function zoomOut() {
            if (currentZoom > 0.5) {
                currentZoom -= 0.25;
                updateZoom();
            }
        }
        
        // Update zoom level for pattern cells
        function updateZoom() {
            const cells = document.querySelectorAll('.pattern-cell');
            const isMobile = window.innerWidth <= 768;
            const baseSize = isMobile ? 30 : 45;
            const newSize = Math.round(baseSize * currentZoom);
            
            patternGrid.style.gridTemplateColumns = `repeat(var(--grid-size, 8), ${newSize}px)`;
        }
        
        // Update hex input when color picker changes
        function updateColorHex() {
            colorHex.value = colorPicker.value;
        }
        
        // Update color picker when hex input changes
        function updateColorPicker() {
            // Check if the input is a valid hex color
            const hexRegex = /^#[0-9A-F]{6}$/i;
            let color = colorHex.value;
            
            // Add a # if it's missing
            if (color.charAt(0) !== '#') {
                color = '#' + color;
                colorHex.value = color;
            }
            
            if (hexRegex.test(color)) {
                colorPicker.value = color;
            }
        }
        
        // Show pattern generator section and populate with selected blocks
        function showPatternGenerator() {
            // Clear any existing selected blocks
            selectedPatternBlocks = [...selectedItems]; // Use the blocks we found from color matching
            selectedBlocksContainer.innerHTML = '';
            
            // Display the selected blocks
            if (selectedPatternBlocks.length > 0) {
                selectedPatternBlocks.forEach(block => {
                    const blockElement = document.createElement('div');
                    blockElement.className = 'selected-block';
                    blockElement.innerHTML = `
                        <img src="${block.imgSrc}" alt="${block.displayName}">
                        <span>${block.displayName}</span>
                    `;
                    selectedBlocksContainer.appendChild(blockElement);
                });
            } else {
                const placeholderText = document.createElement('p');
                placeholderText.textContent = 'No blocks selected. Find matching blocks first.';
                selectedBlocksContainer.appendChild(placeholderText);
            }
            
            // Show the pattern generator section
            patternGenerator.style.display = 'block';
            
            // Generate an initial pattern
            generatePattern();
            
            // Scroll to the pattern generator
            patternGenerator.scrollIntoView({ behavior: 'smooth' });
        }
        
        // Load Minecraft items data
        async function loadData() {
            showLoading(true);
            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                
                // Filter items with valid images
                allItems = data.items.filter(item => item.imgSrc && item.imgSrc.startsWith('data:image'));
                
                showLoading(false);
            } catch (error) {
                console.error('Error loading data:', error);
                alert('Error loading Minecraft data. Please try again.');
                showLoading(false);
            }
        }
        
        // Generate a pattern based on selected type and blocks
        function generatePattern() {
            // Check if we have selected blocks
            if (selectedPatternBlocks.length === 0) {
                alert('Please select matching blocks first.');
                return;
            }
            
            const patternType = patternTypeSelect.value;
            const gridSize = parseInt(gridSizeInput.value);
            
            // Make sure grid size is valid
            if (gridSize < 4 || gridSize > 16) {
                alert('Grid size must be between 4 and 16.');
                return;
            }
            
            // Clear the pattern preview
            patternGrid.innerHTML = '';
            patternGrid.style.setProperty('--grid-size', gridSize);
            
            // Generate the pattern based on the selected type
            switch (patternType) {
                case 'checkerboard':
                    generateCheckerboard(gridSize);
                    break;
                case 'stripes':
                    generateStripes(gridSize);
                    break;
                case 'random':
                    generateRandom(gridSize);
                    break;
                case 'border':
                    generateBorder(gridSize);
                    break;
                case 'diagonal':
                    generateDiagonal(gridSize);
                    break;
                case 'circles':
                    generateCircles(gridSize);
                    break;
            }
            
            // Update the zoom
            updateZoom();
        }
        
        // Generate a checkerboard pattern
        function generateCheckerboard(size) {
            // Need at least 2 blocks for a checkerboard
            const blocks = selectedPatternBlocks.length >= 2 
                ? [selectedPatternBlocks[0], selectedPatternBlocks[1]] 
                : [selectedPatternBlocks[0], selectedPatternBlocks[0]];
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const isEven = (x + y) % 2 === 0;
                    const block = isEven ? blocks[0] : blocks[1];
                    createPatternCell(x, y, block);
                }
            }
        }
        
        // Generate stripes pattern
        function generateStripes(size) {
            // Use all selected blocks in rotation
            const blocks = selectedPatternBlocks;
            const blockCount = blocks.length;
            
            for (let y = 0; y < size; y++) {
                const blockIndex = y % blockCount;
                for (let x = 0; x < size; x++) {
                    createPatternCell(x, y, blocks[blockIndex]);
                }
            }
        }
        
        // Generate random pattern
        function generateRandom(size) {
            const blocks = selectedPatternBlocks;
            const blockCount = blocks.length;
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const randomIndex = Math.floor(Math.random() * blockCount);
                    createPatternCell(x, y, blocks[randomIndex]);
                }
            }
        }
        
        // Generate border pattern
        function generateBorder(size) {
            // Need at least 2 blocks for border
            const blocks = selectedPatternBlocks.length >= 2 
                ? [selectedPatternBlocks[0], selectedPatternBlocks[1]] 
                : [selectedPatternBlocks[0], selectedPatternBlocks[0]];
            
            const borderBlock = blocks[0];
            const centerBlock = blocks[1];
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    // If it's on the edge, use border block
                    const isBorder = x === 0 || x === size - 1 || y === 0 || y === size - 1;
                    const block = isBorder ? borderBlock : centerBlock;
                    createPatternCell(x, y, block);
                }
            }
        }
        
        // Generate diagonal pattern
        function generateDiagonal(size) {
            const blocks = selectedPatternBlocks;
            const blockCount = blocks.length;
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    // Calculate diagonal index
                    const diagonalIndex = (x + y) % blockCount;
                    createPatternCell(x, y, blocks[diagonalIndex]);
                }
            }
        }
        
        // Generate circles pattern
        function generateCircles(size) {
            // Need at least 2 blocks for concentric circles
            const blocks = selectedPatternBlocks.length >= 2 
                ? selectedPatternBlocks 
                : [selectedPatternBlocks[0], selectedPatternBlocks[0]];
            
            const center = size / 2;
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    // Calculate distance from center
                    const distance = Math.sqrt(Math.pow(x - center + 0.5, 2) + Math.pow(y - center + 0.5, 2));
                    const ring = Math.floor(distance);
                    const blockIndex = ring % blocks.length;
                    createPatternCell(x, y, blocks[blockIndex]);
                }
            }
        }
        
        // Create a cell in the pattern grid
        function createPatternCell(x, y, block) {
            const cell = document.createElement('div');
            cell.className = 'pattern-cell';
            cell.title = block.displayName;
            
            const img = document.createElement('img');
            img.src = block.imgSrc;
            img.alt = block.displayName;
            img.loading = "lazy"; // Add lazy loading for better performance
            
            cell.appendChild(img);
            patternGrid.appendChild(cell);
        }
        
        // Find blocks that match the selected color
        async function findMatchingBlocks() {
            showLoading(true);
            
            const baseColor = colorPicker.value;
            const blockCount = parseInt(blockCountSelect.value);
            
            // Reset pattern generator
            patternGenerator.style.display = 'none';
            
            // Generate monochromatic colors without duplicates
            palette = generateMonochromaticColors(baseColor);
            
            // Make sure we have precomputed the color data for all items
            await precomputeItemColors();
            
            // Find the best matching blocks for the selected color
            selectedItems = findBestMatchingBlocks(baseColor, blockCount);
            
            // Display the results
            displayResults();
            showLoading(false);
        }
        
        // Generate monochromatic colors from a base color
        function generateMonochromaticColors(baseColor) {
            const hsl = hexToHSL(baseColor);
            const colors = new Set([baseColor]);
            
            // For grayscale colors (very low saturation), generate proper grayscale palette
            if (hsl.s < 10) {
                // Generate grayscale variations
                colors.add(hslToHex(0, 0, Math.min(hsl.l + 15, 95)));
                colors.add(hslToHex(0, 0, Math.max(hsl.l - 15, 5)));
                colors.add(hslToHex(0, 0, Math.min(hsl.l + 30, 100)));
                colors.add(hslToHex(0, 0, Math.max(hsl.l - 30, 0)));
            } else {
                // For colors with saturation, create proper monochromatic variations
                colors.add(hslToHex(hsl.h, hsl.s, Math.min(hsl.l + 20, 90)));
                colors.add(hslToHex(hsl.h, Math.max(hsl.s - 15, 10), hsl.l));
                colors.add(hslToHex(hsl.h, Math.min(hsl.s + 15, 100), Math.max(hsl.l - 20, 10)));
                colors.add(hslToHex(hsl.h, hsl.s, Math.max(hsl.l - 35, 5)));
            }
            
            // Remove any duplicates and convert to array
            return Array.from(colors);
        }
        
        // Precompute dominant colors for all items
        async function precomputeItemColors() {
            if (dominantColors.size > 0) return; // Skip if already computed
            
            for (const item of allItems) {
                try {
                    const colors = await extractColors(item.imgSrc);
                    dominantColors.set(item.itemId, colors);
                } catch (error) {
                    console.error(`Error processing ${item.displayName}:`, error);
                    dominantColors.set(item.itemId, []);
                }
            }
        }
        
        // Find blocks that best match the selected color
        function findBestMatchingBlocks(baseColor, count) {
            const baseHSL = hexToHSL(baseColor);
            
            // Identify the color category based on HSL
            const colorCategory = identifyColorCategory(baseHSL);
            
            // Get items from that color category
            const colorMatchItems = getItemsFromColorCategory(colorCategory);
            
            // Create a scoring system for items
            const scoredItems = allItems.map(item => {
                // Start with a base score
                let score = 100;
                
                // If the item is in our color category list, give it a big boost
                if (colorMatchItems.includes(item.itemId)) {
                    score += 1000;
                }
                
                // Calculate color similarity
                const colors = dominantColors.get(item.itemId) || [];
                if (colors.length > 0) {
                    // Find the closest color match
                    const bestScore = Math.max(...colors.map(color => {
                        const colorHSL = hexToHSL(color);
                        return calculateColorScore(baseHSL, colorHSL);
                    }));
                    
                    score += bestScore;
                } else {
                    // Penalize items without colors
                    score -= 500;
                }
                
                return { item, score };
            });
            
            // Sort by score (highest first)
            scoredItems.sort((a, b) => b.score - a.score);
            
            // Take the top matches
            return scoredItems.slice(0, count).map(item => item.item);
        }
        
        // Identify the color category based on HSL values
        function identifyColorCategory(hsl) {
            // Check if it's grayscale first (very low saturation)
            if (hsl.s < 15) {
                if (hsl.l > 85) return 'white';
                if (hsl.l > 60) return 'lightGray';
                if (hsl.l > 30) return 'gray';
                return 'black';
            }
            
            // For colors with saturation, check the hue
            const hue = hsl.h;
            
            if (hue >= 345 || hue < 10) return 'red';
            if (hue >= 10 && hue < 40) return 'orange';
            if (hue >= 40 && hue < 65) return 'yellow';
            if (hue >= 65 && hue < 80) return 'lime';
            if (hue >= 80 && hue < 140) return 'green';
            if (hue >= 140 && hue < 170) return 'cyan';
            if (hue >= 170 && hue < 195) return 'lightBlue';
            if (hue >= 195 && hue < 240) return 'blue';
            if (hue >= 240 && hue < 280) return 'purple';
            if (hue >= 280 && hue < 320) return 'magenta';
            if (hue >= 320 && hue < 345) return 'pink';
            
            // Fallback
            return 'gray';
        }
        
        // Get items from a specific color category
        function getItemsFromColorCategory(category) {
            return colorCatalog[category] || [];
        }
        
        // Calculate a score for how well two colors match (higher is better)
        function calculateColorScore(hsl1, hsl2) {
            // For grayscale colors, focus on lightness
            if (hsl1.s < 15 && hsl2.s < 15) {
                // Calculate lightness difference (smaller is better)
                const lightnessDiff = Math.abs(hsl1.l - hsl2.l);
                // Convert to a score (100 is perfect match, 0 is worst)
                return Math.max(0, 100 - lightnessDiff * 2);
            }
            
            // For colored items
            // Calculate hue distance (0-180)
            const hueDiff = Math.min(Math.abs(hsl1.h - hsl2.h), 360 - Math.abs(hsl1.h - hsl2.h));
            // Normalize to 0-100 (0 is best)
            const hueScore = Math.max(0, 100 - (hueDiff / 1.8));
            
            // Calculate saturation and lightness differences
            const satDiff = Math.abs(hsl1.s - hsl2.s);
            const lightDiff = Math.abs(hsl1.l - hsl2.l);
            
            // Normalize to 0-100 (0 is best)
            const satScore = Math.max(0, 100 - satDiff);
            const lightScore = Math.max(0, 100 - lightDiff * 2);
            
            // Weight the components (hue is most important for color matching)
            return (hueScore * 0.6) + (satScore * 0.2) + (lightScore * 0.2);
        }
        
        // Extract dominant colors from an image
        function extractColors(base64Image) {
            return new Promise((resolve) => {
                const img = new Image();
                img.src = base64Image;
                
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    ctx.drawImage(img, 0, 0);
                    
                    // Get pixel data
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const pixels = imageData.data;
                    const colorMap = {};
                    
                    // Analyze all pixels
                    for (let i = 0; i < pixels.length; i += 4) {
                        // Skip transparent pixels
                        if (pixels[i + 3] < 50) continue;
                        
                        const r = pixels[i];
                        const g = pixels[i + 1];
                        const b = pixels[i + 2];
                        
                        // Skip very dark and very light pixels (borderline black/white)
                        const brightness = (r + g + b) / 3;
                        if (brightness < 5 || brightness > 250) continue;
                        
                        // Create a color key with lower precision to group similar colors
                        const colorKey = `${Math.floor(r/5)*5},${Math.floor(g/5)*5},${Math.floor(b/5)*5}`;
                        
                        if (!colorMap[colorKey]) {
                            colorMap[colorKey] = 1;
                        } else {
                            colorMap[colorKey]++;
                        }
                    }
                    
                    // Sort colors by frequency and convert to hex
                    const sortedColors = Object.entries(colorMap)
                        .filter(([_, count]) => count > 3) // Filter out rare colors
                        .sort(([_, countA], [__, countB]) => countB - countA)
                        .slice(0, 3) // Take only the top 3 dominant colors
                        .map(([color]) => {
                            const [r, g, b] = color.split(',').map(Number);
                            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
                        });
                        
                    resolve(sortedColors);
                };
            });
        }
        
        // Convert hex to HSL
        function hexToHSL(hex) {
            const rgb = hexToRgb(hex);
            const r = rgb.r / 255;
            const g = rgb.g / 255;
            const b = rgb.b / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h = Math.round(h * 60);
            }
            
            s = Math.round(s * 100);
            l = Math.round(l * 100);
            
            return { h, s, l };
        }
        
        // Convert HSL to hex
        function hslToHex(h, s, l) {
            h = h % 360;
            if (h < 0) h += 360;
            s /= 100;
            l /= 100;
            
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;
            
            if (h >= 0 && h < 60) {
                r = c; g = x; b = 0;
            } else if (h >= 60 && h < 120) {
                r = x; g = c; b = 0;
            } else if (h >= 120 && h < 180) {
                r = 0; g = c; b = x;
            } else if (h >= 180 && h < 240) {
                r = 0; g = x; b = c;
            } else if (h >= 240 && h < 300) {
                r = x; g = 0; b = c;
            } else {
                r = c; g = 0; b = x;
            }
            
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);
            
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
        }
        
        // Convert hex to RGB
        function hexToRgb(hex) {
            hex = hex.replace(/^#/, '');
            if (hex.length === 3) {
                hex = hex.split('').map(c => c + c).join('');
            }
            
            const result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }
        
        // Display the color palette results
        function displayResults() {
            // Clear result containers
            paletteDisplay.innerHTML = '';
            blocksGrid.innerHTML = '';
            
            // Display the palette colors
            palette.forEach(color => {
                const colorItem = document.createElement('div');
                colorItem.className = 'color-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = color;
                colorBox.title = 'Click to copy';
                colorBox.addEventListener('click', () => copyToClipboard(color));
                
                const colorHexValue = document.createElement('div');
                colorHexValue.className = 'color-hex';
                colorHexValue.textContent = color;
                
                colorItem.appendChild(colorBox);
                colorItem.appendChild(colorHexValue);
                paletteDisplay.appendChild(colorItem);
            });
            
            // Display the matching blocks
            selectedItems.forEach(item => {
                const blockItem = document.createElement('div');
                blockItem.className = 'block-item';
                
                const blockImage = document.createElement('img');
                blockImage.src = item.imgSrc;
                blockImage.alt = item.displayName;
                blockImage.className = 'block-image';
                
                const blockName = document.createElement('div');
                blockName.className = 'block-name';
                blockName.textContent = item.displayName;
                
                blockItem.appendChild(blockImage);
                blockItem.appendChild(blockName);
                blocksGrid.appendChild(blockItem);
            });
            
            // Show the results container
            resultsContainer.style.display = 'block';
        }
        
        // Copy color to clipboard
        function copyToClipboard(color) {
            navigator.clipboard.writeText(color)
                .then(() => {
                    alert(`Color ${color} copied to clipboard!`);
                })
                .catch(err => {
                    console.error('Failed to copy:', err);
                });
        }
        
        // Show or hide loading overlay
        function showLoading(show) {
            loadingOverlay.style.display = show ? 'flex' : 'none';
            findBtn.disabled = show;
            generatePatternBtn.disabled = show;
        }
    </script>
</body>
</html>
