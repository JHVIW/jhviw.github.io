<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Color Palette</title>
    <style>
        :root {
            --primary-color: #27ae60;
            --primary-hover: #2ecc71;
            --background-dark: #1a1a1a;
            --background-medium: #2d2d2d;
            --background-light: #3a3a3a;
            --background-lighter: #444444;
            --text-light: #ffffff;
            --text-dim: #aaaaaa;
            --accent-color: #f1c40f;
            --border-radius: 8px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--background-dark);
            color: var(--text-light);
            line-height: 1.5;
            overflow-x: hidden;
        }
        
        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            background-color: var(--background-medium);
            padding: 20px;
            border-radius: var(--border-radius);
        }
        
        .color-input-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }
        
        input[type="color"] {
            width: 60px;
            height: 60px;
            border: 2px solid white;
            border-radius: var(--border-radius);
            cursor: pointer;
            background: none;
            padding: 0;
        }
        
        input[type="text"] {
            padding: 12px 15px;
            border-radius: var(--border-radius);
            border: none;
            background-color: var(--background-light);
            color: var(--text-light);
            font-family: monospace;
            width: 120px;
            font-size: 1rem;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            color: var(--text-dim);
            margin-right: 5px;
        }
        
        select {
            padding: 12px;
            border-radius: var(--border-radius);
            border: none;
            background-color: var(--background-light);
            color: var(--text-light);
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
            padding-right: 35px;
        }
        
        .find-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 25px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            min-width: 150px;
        }
        
        .find-btn:hover {
            background-color: var(--primary-hover);
        }
        
        .find-btn:disabled {
            background-color: var(--background-light);
            cursor: not-allowed;
        }
        
        .section-title {
            color: var(--accent-color);
            font-size: 1.8rem;
            margin-bottom: 20px;
        }
        
        .palette-display {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .color-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .color-box {
            width: 70px;
            height: 70px;
            border-radius: var(--border-radius);
            cursor: pointer;
            margin-bottom: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
            border: 2px solid var(--background-lighter);
        }
        
        .color-box:hover {
            transform: scale(1.05);
        }
        
        .color-hex {
            font-family: monospace;
            font-size: 0.9rem;
            background-color: var(--background-light);
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .blocks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 15px;
        }
        
        .block-item {
            background-color: var(--background-light);
            border-radius: var(--border-radius);
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .block-item:hover {
            transform: translateY(-3px);
        }
        
        .block-image {
            width: 64px;
            height: 64px;
            image-rendering: pixelated;
            margin-bottom: 12px;
        }
        
        .block-name {
            font-size: 0.9rem;
            text-align: center;
            word-wrap: break-word;
            line-height: 1.3;
        }
        
        .footer {
            font-size: 0.9rem;
            color: var(--text-dim);
            text-align: center;
            margin-top: 40px;
            padding-top: 15px;
            border-top: 1px solid var(--background-medium);
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--background-light);
            border-top: 5px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .results-container {
            display: none;
        }
        
        hr {
            border: none;
            border-top: 1px solid var(--background-light);
            margin: 30px 0;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .color-picker-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .color-input-group {
                width: 100%;
                margin-bottom: 15px;
            }
            
            .control-group {
                width: 100%;
                justify-content: space-between;
            }
            
            .find-btn {
                width: 100%;
            }
            
            .blocks-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .color-box {
                width: 60px;
                height: 60px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="color-picker-container">
            <div class="color-input-group">
                <input type="color" id="color-picker" value="#ffffff">
                <input type="text" id="color-hex" value="#ffffff">
                <div class="control-group">
                    <label for="block-count">Blocks:</label>
                    <select id="block-count">
                        <option value="5" selected>5</option>
                        <option value="8">8</option>
                        <option value="10">10</option>
                    </select>
                </div>
            </div>
            <button id="find-btn" class="find-btn">Find Blocks</button>
        </div>
        
        <div id="results-container" class="results-container">
            <h2 class="section-title">Your Color Palette</h2>
            <div id="palette-display" class="palette-display">
                <!-- Color palette items will be added here -->
            </div>
            
            <h2 class="section-title">Matching Minecraft Blocks</h2>
            <div id="blocks-grid" class="blocks-grid">
                <!-- Block items will be added here -->
            </div>
        </div>
        
        <footer class="footer">
            <p>Created by Minecraft fans for Minecraft fans. Minecraft is owned by Mojang Studios.</p>
        </footer>
    </div>
    
    <div id="loading-overlay" class="loading-overlay">
        <div class="spinner"></div>
    </div>

    <script>
        // Global variables
        let allItems = [];
        let selectedItems = [];
        let palette = [];
        let dominantColors = new Map(); // Cache for dominant colors in items
        const apiUrl = 'https://raw.githubusercontent.com/JHVIW/MineCatalog/main/minecraft-items.json';
        
        // Color catalog - organized by color groups for better matching
        const colorCatalog = {
            white: [
                "white_concrete", "white_wool", "white_terracotta", "white_stained_glass", 
                "bone_block", "diorite", "polished_diorite", "quartz_block", "snow_block", 
                "white_glazed_terracotta", "white_shulker_box", "white_concrete_powder",
                "calcite", "birch_planks", "birch_log", "birch_wood", "mushroom_stem"
            ],
            lightGray: [
                "light_gray_concrete", "light_gray_wool", "light_gray_terracotta", 
                "light_gray_stained_glass", "clay", "cobblestone", "stone", "andesite", 
                "polished_andesite", "light_gray_glazed_terracotta", "light_gray_concrete_powder"
            ],
            gray: [
                "gray_concrete", "gray_wool", "gray_terracotta", "gray_stained_glass",
                "gray_glazed_terracotta", "gray_concrete_powder", "polished_basalt", "basalt",
                "stone_bricks", "cracked_stone_bricks", "dead_brain_coral_block", "tuff"
            ],
            black: [
                "black_concrete", "black_wool", "black_terracotta", "black_stained_glass",
                "black_glazed_terracotta", "black_concrete_powder", "coal_block", 
                "obsidian", "blackstone", "polished_blackstone", "basalt", "deepslate",
                "polished_deepslate", "deepslate_tiles", "deepslate_bricks"
            ],
            red: [
                "red_concrete", "red_wool", "red_terracotta", "red_stained_glass",
                "red_glazed_terracotta", "red_concrete_powder", "red_mushroom_block",
                "nether_wart_block", "crimson_stem", "crimson_planks", "crimson_hyphae",
                "red_nether_bricks", "redstone_block", "redstone_ore", "nether_gold_ore"
            ],
            orange: [
                "orange_concrete", "orange_wool", "orange_terracotta", "orange_stained_glass",
                "orange_glazed_terracotta", "orange_concrete_powder", "copper_block",
                "cut_copper", "exposed_copper", "acacia_planks", "acacia_log", "acacia_wood",
                "pumpkin", "terracotta", "brown_mushroom_block"
            ],
            yellow: [
                "yellow_concrete", "yellow_wool", "yellow_terracotta", "yellow_stained_glass",
                "yellow_glazed_terracotta", "yellow_concrete_powder", "hay_block",
                "gold_block", "raw_gold_block", "bee_nest", "honeycomb_block",
                "honey_block", "sponge", "wet_sponge", "yellow_flower"
            ],
            lime: [
                "lime_concrete", "lime_wool", "lime_terracotta", "lime_stained_glass",
                "lime_glazed_terracotta", "lime_concrete_powder", "melon", "slime_block"
            ],
            green: [
                "green_concrete", "green_wool", "green_terracotta", "green_stained_glass",
                "green_glazed_terracotta", "green_concrete_powder", "moss_block",
                "emerald_block", "emerald_ore", "oak_leaves", "spruce_leaves", "jungle_leaves",
                "dark_oak_leaves", "dried_kelp_block", "seagrass", "cactus"
            ],
            cyan: [
                "cyan_concrete", "cyan_wool", "cyan_terracotta", "cyan_stained_glass",
                "cyan_glazed_terracotta", "cyan_concrete_powder", "prismarine",
                "prismarine_bricks", "dark_prismarine", "warped_stem", "warped_planks",
                "warped_hyphae", "oxidized_copper", "oxidized_cut_copper"
            ],
            lightBlue: [
                "light_blue_concrete", "light_blue_wool", "light_blue_terracotta", 
                "light_blue_stained_glass", "light_blue_glazed_terracotta", 
                "light_blue_concrete_powder", "ice", "packed_ice", "soul_soil"
            ],
            blue: [
                "blue_concrete", "blue_wool", "blue_terracotta", "blue_stained_glass",
                "blue_glazed_terracotta", "blue_concrete_powder", "blue_ice",
                "lapis_block", "lapis_ore", "diamond_block", "diamond_ore", "soul_soil"
            ],
            purple: [
                "purple_concrete", "purple_wool", "purple_terracotta", "purple_stained_glass",
                "purple_glazed_terracotta", "purple_concrete_powder", "purpur_block",
                "purpur_pillar", "amethyst_block", "budding_amethyst", "mycelium"
            ],
            magenta: [
                "magenta_concrete", "magenta_wool", "magenta_terracotta", "magenta_stained_glass",
                "magenta_glazed_terracotta", "magenta_concrete_powder", "purpur_block", 
                "chorus_flower", "chorus_plant", "amethyst_cluster"
            ],
            pink: [
                "pink_concrete", "pink_wool", "pink_terracotta", "pink_stained_glass",
                "pink_glazed_terracotta", "pink_concrete_powder", "brain_coral_block", 
                "bubble_coral_block", "cherry_planks", "cherry_log", "cherry_wood"
            ],
            brown: [
                "brown_concrete", "brown_wool", "brown_terracotta", "brown_stained_glass",
                "brown_glazed_terracotta", "brown_concrete_powder", "soul_sand",
                "oak_log", "oak_planks", "oak_wood", "jungle_log", "jungle_planks",
                "jungle_wood", "dark_oak_log", "dark_oak_planks", "dark_oak_wood",
                "spruce_log", "spruce_planks", "spruce_wood", "dirt", "coarse_dirt",
                "rooted_dirt", "mud", "mud_bricks", "packed_mud", "mangrove_log", 
                "mangrove_planks", "mangrove_wood", "mangrove_roots", "muddy_mangrove_roots"
            ]
        };
        
        // DOM elements
        const colorPicker = document.getElementById('color-picker');
        const colorHex = document.getElementById('color-hex');
        const blockCountSelect = document.getElementById('block-count');
        const findBtn = document.getElementById('find-btn');
        const resultsContainer = document.getElementById('results-container');
        const paletteDisplay = document.getElementById('palette-display');
        const blocksGrid = document.getElementById('blocks-grid');
        const loadingOverlay = document.getElementById('loading-overlay');
        
        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            loadData();
            
            // Event listeners
            colorPicker.addEventListener('input', updateColorHex);
            colorHex.addEventListener('input', updateColorPicker);
            findBtn.addEventListener('click', findMatchingBlocks);
        });
        
        // Update hex input when color picker changes
        function updateColorHex() {
            colorHex.value = colorPicker.value;
        }
        
        // Update color picker when hex input changes
        function updateColorPicker() {
            // Check if the input is a valid hex color
            const hexRegex = /^#[0-9A-F]{6}$/i;
            let color = colorHex.value;
            
            // Add a # if it's missing
            if (color.charAt(0) !== '#') {
                color = '#' + color;
                colorHex.value = color;
            }
            
            if (hexRegex.test(color)) {
                colorPicker.value = color;
            }
        }
        
        // Load Minecraft items data
        async function loadData() {
            showLoading(true);
            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                
                // Filter items with valid images
                allItems = data.items.filter(item => item.imgSrc && item.imgSrc.startsWith('data:image'));
                
                showLoading(false);
            } catch (error) {
                console.error('Error loading data:', error);
                alert('Error loading Minecraft data. Please try again.');
                showLoading(false);
            }
        }
        
        // Find blocks that match the selected color
        async function findMatchingBlocks() {
            showLoading(true);
            
            const baseColor = colorPicker.value;
            const blockCount = parseInt(blockCountSelect.value);
            
            // Generate monochromatic colors without duplicates
            palette = generateMonochromaticColors(baseColor);
            
            // Make sure we have precomputed the color data for all items
            await precomputeItemColors();
            
            // Find the best matching blocks for the selected color
            selectedItems = findBestMatchingBlocks(baseColor, blockCount);
            
            // Display the results
            displayResults();
            showLoading(false);
        }
        
        // Generate monochromatic colors from a base color
        function generateMonochromaticColors(baseColor) {
            const hsl = hexToHSL(baseColor);
            const colors = new Set([baseColor]);
            
            // For grayscale colors (very low saturation), generate proper grayscale palette
            if (hsl.s < 10) {
                // Generate grayscale variations
                colors.add(hslToHex(0, 0, Math.min(hsl.l + 15, 95)));
                colors.add(hslToHex(0, 0, Math.max(hsl.l - 15, 5)));
                colors.add(hslToHex(0, 0, Math.min(hsl.l + 30, 100)));
                colors.add(hslToHex(0, 0, Math.max(hsl.l - 30, 0)));
            } else {
                // For colors with saturation, create proper monochromatic variations
                colors.add(hslToHex(hsl.h, hsl.s, Math.min(hsl.l + 20, 90)));
                colors.add(hslToHex(hsl.h, Math.max(hsl.s - 15, 10), hsl.l));
                colors.add(hslToHex(hsl.h, Math.min(hsl.s + 15, 100), Math.max(hsl.l - 20, 10)));
                colors.add(hslToHex(hsl.h, hsl.s, Math.max(hsl.l - 35, 5)));
            }
            
            // Remove any duplicates and convert to array
            return Array.from(colors);
        }
        
        // Precompute dominant colors for all items
        async function precomputeItemColors() {
            if (dominantColors.size > 0) return; // Skip if already computed
            
            for (const item of allItems) {
                try {
                    const colors = await extractColors(item.imgSrc);
                    dominantColors.set(item.itemId, colors);
                } catch (error) {
                    console.error(`Error processing ${item.displayName}:`, error);
                    dominantColors.set(item.itemId, []);
                }
            }
        }
        
        // Find blocks that best match the selected color
        function findBestMatchingBlocks(baseColor, count) {
            const baseHSL = hexToHSL(baseColor);
            
            // Identify the color category based on HSL
            const colorCategory = identifyColorCategory(baseHSL);
            
            // Get items from that color category
            const colorMatchItems = getItemsFromColorCategory(colorCategory);
            
            // Create a scoring system for items
            const scoredItems = allItems.map(item => {
                // Start with a base score
                let score = 100;
                
                // If the item is in our color category list, give it a big boost
                if (colorMatchItems.includes(item.itemId)) {
                    score += 1000;
                }
                
                // Calculate color similarity
                const colors = dominantColors.get(item.itemId) || [];
                if (colors.length > 0) {
                    // Find the closest color match
                    const bestScore = Math.max(...colors.map(color => {
                        const colorHSL = hexToHSL(color);
                        return calculateColorScore(baseHSL, colorHSL);
                    }));
                    
                    score += bestScore;
                } else {
                    // Penalize items without colors
                    score -= 500;
                }
                
                return { item, score };
            });
            
            // Sort by score (highest first)
            scoredItems.sort((a, b) => b.score - a.score);
            
            // Take the top matches
            return scoredItems.slice(0, count).map(item => item.item);
        }
        
        // Identify the color category based on HSL values
        function identifyColorCategory(hsl) {
            // Check if it's grayscale first (very low saturation)
            if (hsl.s < 15) {
                if (hsl.l > 85) return 'white';
                if (hsl.l > 60) return 'lightGray';
                if (hsl.l > 30) return 'gray';
                return 'black';
            }
            
            // For colors with saturation, check the hue
            const hue = hsl.h;
            
            if (hue >= 345 || hue < 10) return 'red';
            if (hue >= 10 && hue < 40) return 'orange';
            if (hue >= 40 && hue < 65) return 'yellow';
            if (hue >= 65 && hue < 80) return 'lime';
            if (hue >= 80 && hue < 140) return 'green';
            if (hue >= 140 && hue < 170) return 'cyan';
            if (hue >= 170 && hue < 195) return 'lightBlue';
            if (hue >= 195 && hue < 240) return 'blue';
            if (hue >= 240 && hue < 280) return 'purple';
            if (hue >= 280 && hue < 320) return 'magenta';
            if (hue >= 320 && hue < 345) return 'pink';
            
            // Fallback
            return 'gray';
        }
        
        // Get items from a specific color category
        function getItemsFromColorCategory(category) {
            return colorCatalog[category] || [];
        }
        
        // Calculate a score for how well two colors match (higher is better)
        function calculateColorScore(hsl1, hsl2) {
            // For grayscale colors, focus on lightness
            if (hsl1.s < 15 && hsl2.s < 15) {
                // Calculate lightness difference (smaller is better)
                const lightnessDiff = Math.abs(hsl1.l - hsl2.l);
                // Convert to a score (100 is perfect match, 0 is worst)
                return Math.max(0, 100 - lightnessDiff * 2);
            }
            
            // For colored items
            // Calculate hue distance (0-180)
            const hueDiff = Math.min(Math.abs(hsl1.h - hsl2.h), 360 - Math.abs(hsl1.h - hsl2.h));
            // Normalize to 0-100 (0 is best)
            const hueScore = Math.max(0, 100 - (hueDiff / 1.8));
            
            // Calculate saturation and lightness differences
            const satDiff = Math.abs(hsl1.s - hsl2.s);
            const lightDiff = Math.abs(hsl1.l - hsl2.l);
            
            // Normalize to 0-100 (0 is best)
            const satScore = Math.max(0, 100 - satDiff);
            const lightScore = Math.max(0, 100 - lightDiff * 2);
            
            // Weight the components (hue is most important for color matching)
            return (hueScore * 0.6) + (satScore * 0.2) + (lightScore * 0.2);
        }
        
        // Extract dominant colors from an image
        function extractColors(base64Image) {
            return new Promise((resolve) => {
                const img = new Image();
                img.src = base64Image;
                
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    ctx.drawImage(img, 0, 0);
                    
                    // Get pixel data
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const pixels = imageData.data;
                    const colorMap = {};
                    
                    // Analyze all pixels
                    for (let i = 0; i < pixels.length; i += 4) {
                        // Skip transparent pixels
                        if (pixels[i + 3] < 50) continue;
                        
                        const r = pixels[i];
                        const g = pixels[i + 1];
                        const b = pixels[i + 2];
                        
                        // Skip very dark and very light pixels (borderline black/white)
                        const brightness = (r + g + b) / 3;
                        if (brightness < 5 || brightness > 250) continue;
                        
                        // Create a color key with lower precision to group similar colors
                        const colorKey = `${Math.floor(r/5)*5},${Math.floor(g/5)*5},${Math.floor(b/5)*5}`;
                        
                        if (!colorMap[colorKey]) {
                            colorMap[colorKey] = 1;
                        } else {
                            colorMap[colorKey]++;
                        }
                    }
                    
                    // Sort colors by frequency and convert to hex
                    const sortedColors = Object.entries(colorMap)
                        .filter(([_, count]) => count > 3) // Filter out rare colors
                        .sort(([_, countA], [__, countB]) => countB - countA)
                        .slice(0, 3) // Take only the top 3 dominant colors
                        .map(([color]) => {
                            const [r, g, b] = color.split(',').map(Number);
                            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
                        });
                        
                    resolve(sortedColors);
                };
            });
        }
        
        // Convert hex to HSL
        function hexToHSL(hex) {
            const rgb = hexToRgb(hex);
            const r = rgb.r / 255;
            const g = rgb.g / 255;
            const b = rgb.b / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h = Math.round(h * 60);
            }
            
            s = Math.round(s * 100);
            l = Math.round(l * 100);
            
            return { h, s, l };
        }
        
        // Convert HSL to hex
        function hslToHex(h, s, l) {
            h = h % 360;
            if (h < 0) h += 360;
            s /= 100;
            l /= 100;
            
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;
            
            if (h >= 0 && h < 60) {
                r = c; g = x; b = 0;
            } else if (h >= 60 && h < 120) {
                r = x; g = c; b = 0;
            } else if (h >= 120 && h < 180) {
                r = 0; g = c; b = x;
            } else if (h >= 180 && h < 240) {
                r = 0; g = x; b = c;
            } else if (h >= 240 && h < 300) {
                r = x; g = 0; b = c;
            } else {
                r = c; g = 0; b = x;
            }
            
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);
            
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
        }
        
        // Convert hex to RGB
        function hexToRgb(hex) {
            hex = hex.replace(/^#/, '');
            if (hex.length === 3) {
                hex = hex.split('').map(c => c + c).join('');
            }
            
            const result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }
        
        // Display the results
        function displayResults() {
            // Clear result containers
            paletteDisplay.innerHTML = '';
            blocksGrid.innerHTML = '';
            
            // Display the palette colors
            palette.forEach(color => {
                const colorItem = document.createElement('div');
                colorItem.className = 'color-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = color;
                colorBox.title = 'Click to copy';
                colorBox.addEventListener('click', () => copyToClipboard(color));
                
                const colorHexValue = document.createElement('div');
                colorHexValue.className = 'color-hex';
                colorHexValue.textContent = color;
                
                colorItem.appendChild(colorBox);
                colorItem.appendChild(colorHexValue);
                paletteDisplay.appendChild(colorItem);
            });
            
            // Display the matching blocks
            selectedItems.forEach(item => {
                const blockItem = document.createElement('div');
                blockItem.className = 'block-item';
                
                const blockImage = document.createElement('img');
                blockImage.src = item.imgSrc;
                blockImage.alt = item.displayName;
                blockImage.className = 'block-image';
                
                const blockName = document.createElement('div');
                blockName.className = 'block-name';
                blockName.textContent = item.displayName;
                
                blockItem.appendChild(blockImage);
                blockItem.appendChild(blockName);
                blocksGrid.appendChild(blockItem);
            });
            
            // Show the results container
            resultsContainer.style.display = 'block';
        }
        
        // Copy color to clipboard
        function copyToClipboard(color) {
            navigator.clipboard.writeText(color)
                .then(() => {
                    alert(`Color ${color} copied to clipboard!`);
                })
                .catch(err => {
                    console.error('Failed to copy:', err);
                });
        }
        
        // Show or hide loading overlay
        function showLoading(show) {
            loadingOverlay.style.display = show ? 'flex' : 'none';
            findBtn.disabled = show;
        }
    </script>
</body>
</html>
